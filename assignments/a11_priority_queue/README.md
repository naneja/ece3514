# A11: Priority Queue



## Problem 1: Efficient File Merge Cost


In a distributed system, multiple sorted log files are generated by different servers. These files need to be merged into a single sorted file. The cost of merging two files is proportional to the sum of their sizes (in MB). To minimize the total cost of merging all files, the system must merge the two smallest files first - this ensures minimal cumulative I/O cost. You are given an array of integers where each element represents the size (in MB) of a sorted file. Implement a function to compute the minimum total cost of merging all files into one. Use an efficient approach.

Requirements:
Write a function in C++ called `min_merge_cost` that takes a vector of integers and returns the minimum total cost of merging. Use Priority Queue

Function Signature:
```cpp
int min_merge_cost(const std::vector<int>& fileSizes);
```

Given file sizes: [10, 20, 30]

**Strategy 1:**
Merge 10 + 20 -> cost = 30 and File Size = 30
Pending Files: 30 MB previous and 30 MB New
Merge 30 + 30 -> cost = 60
Pending Files: 60 MB (only 1 file left now so terminate)
Total cost = 30 + 60 = 90

**Strategy 2:**
Merge 20 + 30 -> cost = 50 and new File Size = 50
Pending Files: 10 MB and 50 MB
Merge 10 + 50 → cost = 60 and File new File Size = 60 MB
Total cost = 50 + 60 = 110

Strategy 1 is better as it has total lower cost. You need to write algorithm to implement strategy that provides lower cost. Use Priority Queue.



## Problem 2: Top $\sqrt{N}$ Selection

You are implementing an algorithm that draws part of the landscape of a terrain, and you are faced with the following problem: You are given the heights of N points of the terrain’s grid, and you need to find and sort, as fast as possible, the square_root(N) highest of them. Round square root to ceiling. 

Constraints & Requirements:
* Use a min-heap (priority queue) whose size never exceeds square_root(N)
* Overall extra space must be O(k)
* If N = 0, return an empty result.
* Duplicates may appear in the input


Allowed: std::vector, std::priority_queue, std::reverse, std::min, std::max, std::less, std::greater, ceil, sqrt

Use the memory of vector and priority_queue efficiently (e.g., pre-reserve when appropriate).

Function signature:

```cpp
std::vector<int> top_sqrtN_sorted(const std::vector<int>& A);
```

The function returns the k largest elements of A, in descending order



### Submissions:

* Problem 1: min_merge_cost.hpp 
* Problem 2: sort_sqn.hpp
* No other file to be submitted

### Rubrics:

* Use Priority Queue on all operations. Vector is used efficiently to read the data.
* Priority Queue size never exceeds square_root(N) in Problem 2.